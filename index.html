<!doctype html>
<html lang="en-NZ">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Score-It!</title>

<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#ffffff">

<style>
:root{
  --bg: #f8f9fb;
  --card: #ffffff;
  --muted: #6b7280;
  --accent: #003493;
  --accent-2: #EA0063;
  --radius: 14px;
  --pill: rgba(0,0,0,0.05);
  --shadow: 0 8px 26px rgba(7,11,23,0.08);
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  color-scheme: light;
}
html,body{height:100%;margin:0;background:linear-gradient(#f8f9fb,#f3f6fa);-webkit-font-smoothing:antialiased;}
.app{max-width:820px;margin:10px auto;padding:14px;box-sizing:border-box;}
header.top-pill{
  display:none;
}
/* Floating pill for navigation (bottom-left) */
.bottom-left-pill{
  position:fixed;left:25px;bottom:25px;
  background:linear-gradient(180deg, rgba(255,255,255,0.97), rgba(255,255,255,0.92));
  padding:8px 12px;border-radius:30px;display:flex;gap:8px;align-items:center;
  box-shadow:var(--shadow);z-index:600;border:1px solid rgba(0,0,0,0.04);
}
/* Floating pill for jumpToLatest (bottom-right) */
.bottom-right-pill{
  position:fixed;right:25px;bottom:25px;
  background:var(--accent);
  color: #fff;
  padding:8px 8px;border-radius:30px;display:flex;gap:8px;align-items:center;justify-content:center;
  box-shadow:var(--shadow);z-index:600;border:1px solid rgba(0,0,0,0.04);
  width:42px;height:42px;
}
.icon-btn{width:42px;height:42px;border-radius:10px;background:transparent;border:0;display:grid;place-items:center;font-size:18px;cursor:pointer;color:inherit}
h1{font-size:20px;margin:10px 0 6px 0;color:#0f1724}
.card{background:var(--card);border-radius:var(--radius);padding:14px;margin:12px 0;box-shadow:var(--shadow);border:1px solid rgba(0,0,0,0.03)}
.home-actions{display:flex;gap:10px;flex-wrap:wrap}
.btn{background:var(--accent);color:white;padding:10px 14px;border-radius:8px;border:0;cursor:pointer;font-weight:600}
.btn.ghost{background:transparent;color:var(--accent);border:1px solid rgba(0,52,147,0.12)}
.muted{color:var(--muted);font-size:14px}
textarea {width:100%;box-sizing:border-box;min-height:120px;padding:10px;border-radius:10px;border:1px solid rgba(0,0,0,0.06);resize:vertical;font-size:16px}
input[type="text"], input[type="number"]{padding:10px;border-radius:10px;border:1px solid rgba(0,0,0,0.06);font-size:16px}
label{display:block;margin:10px 0 6px 0;font-weight:600;color:#0f1724}

/* Scoresheet list */
.row{display:flex;align-items:center;gap:12px;padding:10px;border-radius:10px;}
.row:not(.active){opacity:0.62}
.active{background: #eee;}
.left{flex:1}
.name{font-weight:700;font-size:16px;color:#081227}
.subtitle{font-size:13px;color:var(--muted);margin-top:4px;white-space:nowrap;overflow:auto}
.right{width:100px}
.score-input{width:90px;padding:8px 4px;border-radius:8px;border:1px solid rgba(0,0,0,0.06);font-size:16px;text-align:center}
.list{display:flex;flex-direction:column;gap:8px}
.add-row{display:flex;gap:8px;margin-top:10px}
.small{font-size:13px;padding:8px 10px;border-radius:8px;background:var(--pill);border:0;-webkit-appearance:none;appearance:none;cursor:pointer;color:#0f1724;-webkit-text-fill-color:#0f1724;-webkit-tap-highlight-color: transparent}


#roundSelect {
  /* Inherit height/look from .small */
  font-size: 13px;
  padding: 8px 10px 8px 30px; /* **Crucial:** Increased LEFT padding (30px) to move text away from the icon */
  border-radius: 8px;
  background: var(--pill);
  border: 0;

  /* Additional adjustments for select consistency */
  -webkit-appearance: none; /* Removes default iOS/Safari styling */
  -moz-appearance: none;    /* Removes default Firefox styling */
  appearance: none;         /* Removes default OS styling */
  
  /* Add a custom arrow if desired (optional, but improves consistency) */
  /* background-image: url("data:image/svg+xml;..."); */

  /* Ensure text color is readable, matching input fields */
  color: #0f1724; 
  cursor: pointer;
}

/* Optional: Style the element when focused */
#roundSelect:focus {
  outline: none; /* Remove default browser outline */
  box-shadow: 0 0 0 2px var(--accent); /* Add a custom focus ring */
}

/* New style for the wrapper */
.dropdown-wrapper {
  position: relative; /* Crucial for absolute positioning of the icon */
  display: inline-block; /* Wraps tightly around the select box */
}

/* Style the icon (chevron) */
.dropdown-wrapper::before {
  /* Using your SVG encoded as a Data URI */
  /* The SVG is color: currentColor and stroke-width: 2.5 for better visibility */
  content: ''; 
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2.5' stroke-linecap='round' stroke-linejoin='round' class='feather feather-chevron-down'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
  background-size: 16px 16px; /* Adjust size to fit nicely */
  background-repeat: no-repeat;
  
  /* Positioning and layout */
  position: absolute;
  top: 50%; /* Center vertically */
  left: 8px; /* Slightly adjust left position */
  width: 16px; /* Width of the icon container */
  height: 16px; /* Height of the icon container */
  transform: translateY(-50%); /* Fine-tune vertical centering */
  
  /* Ensure icon is clickable but doesn't interfere with the dropdown's click target */
  pointer-events: none; 
  z-index: 2; /* Ensure it's above the select box */
  
  /* The color is set via 'currentColor' in the SVG, which will inherit from the wrapper's text color.
     Since the wrapper usually doesn't have an explicit color, we'll rely on the select's text color.
     You may want to set a specific color property here if the icon doesn't show up. */
}


.leaderboard table{width:100%;border-collapse:collapse}
.leaderboard th, .leaderboard td{padding:8px;border-bottom:1px solid rgba(0,0,0,0.04);text-align:left;font-size:14px}
.leaderboard th{font-weight:700;color:#0f1724}
.leaderboard td.numeric{text-align:right;font-variant-numeric:tabular-nums}

/* modal */
.modal-backdrop{position:fixed;left:0;top:0;right:0;bottom:0;background:rgba(0,0,0,0.25);display:grid;place-items:center;z-index:800}
.modal{width:92%;max-width:560px;background:var(--card);padding:14px;border-radius:12px;box-shadow:0 20px 50px rgba(9,10,11,0.18)}
.row-grid{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center}
.pills{display:flex;gap:8px;align-items:center}
.delete-confirm{background:var(--accent-2);color:white;padding:8px 12px;border-radius:8px;border:0;font-weight:700}

/* swipe hidden delete is removed - we use modal instead */
.swipe-wrap{position:relative;border-radius:10px;background:transparent}

/* responsive */
@media (max-width:520px){
  .right{width:90px}
  .icon-btn{width:36px;height:36px}
}
.round-pill{display:inline-block;padding:6px 10px;border-radius:999px;background:rgba(0,0,0,0.03);font-size:13px;margin-left:8px}
.top-controls{display:flex;gap:8px;align-items:center}
.rounds-control{display:flex;gap:6px;align-items:center}
.title-row{display:flex;align-items:flex-end;gap:8px;justify-content:space-between}
.title-left{display:flex;align-items:flex-end;gap:10px}
.rename-icon{cursor:pointer;border-radius:8px;padding:0 6px;margin: 0;}
.rename-icon:hover{background:var(--pill)}
.footer-space{height:90px}
</style>
</head>
<body>
<div class="app" id="app">
  <header class="top-pill" aria-hidden="true">
    <button class="icon-btn" id="homeBtn" title="Home">üè†</button>
    <button class="icon-btn" id="secondBtn" title="Secondary">üìÅ</button>
  </header>

  <main id="main"></main>

  <!-- Bottom-left navigation pill -->
  <div class="bottom-left-pill" id="bottomLeftPill">
    <button class="icon-btn" id="homeBtn2" title="Home">üè†</button>
    <button class="icon-btn" id="secondBtn2" title="Secondary">üìÅ</button>
  </div>

  <!-- Bottom-right jumpToLatest pill -->
  <div class="bottom-right-pill" id="bottomRightPill" style="display:none;">
    <button class="icon-btn" id="jumpBtn" title="Jump to Latest" style="font-size:24px;">‚á•</button>
  </div>

  <!-- Home-only bottom-right plus pill (matches jumpBtn style) -->
  <div class="bottom-right-pill" id="homePlusPill" style="display:none;">
    <button class="icon-btn" id="homePlusBtn" title="New Scoresheet" style="font-size:24px;" aria-label="New Scoresheet">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false">
        <line x1="12" y1="5" x2="12" y2="19"></line>
        <line x1="5" y1="12" x2="19" y2="12"></line>
      </svg>
    </button>
  </div>

  <div class="footer-space"></div>
</div>

<!-- modal container -->
<div id="modalRoot" style="display:none;"></div>

<script>
/* ============================
   IndexedDB wrapper
   ============================ */
const DB_NAME = 'scorekeeper-db';
const DB_VER = 1;
const STORE = 'sheets';

/* ============================
   Draft storage for New Scoresheet
   ============================ */
const DRAFT_KEY = 'scorekeeper-draft';
function saveDraft(title, names){
  localStorage.setItem(DRAFT_KEY, JSON.stringify({ title, names }));
}
function loadDraft(){
  const draft = localStorage.getItem(DRAFT_KEY);
  return draft ? JSON.parse(draft) : null;
}
function clearDraft(){
  localStorage.removeItem(DRAFT_KEY);
}

function openDb(){
  return new Promise((res, rej) => {
    const r = indexedDB.open(DB_NAME, DB_VER);
    r.onupgradeneeded = e => {
      const db = e.target.result;
      if (!db.objectStoreNames.contains(STORE)) {
        db.createObjectStore(STORE, { keyPath: 'id' });
      }
    };
    r.onsuccess = e => res(e.target.result);
    r.onerror = e => rej(e.target.error);
  });
}
async function dbGetAll(){ const db = await openDb(); return new Promise((res,rej)=>{ const tx = db.transaction(STORE,'readonly'); const st = tx.objectStore(STORE); const req = st.getAll(); req.onsuccess = ()=>res(req.result); req.onerror = ()=>rej(req.error); }); }
async function dbGet(id){ const db = await openDb(); return new Promise((res,rej)=>{ const tx = db.transaction(STORE,'readonly'); const st = tx.objectStore(STORE); const req = st.get(id); req.onsuccess = ()=>res(req.result); req.onerror = ()=>rej(req.error); }); }
async function dbPut(obj){ const db = await openDb(); return new Promise((res,rej)=>{ const tx = db.transaction(STORE,'readwrite'); const st = tx.objectStore(STORE); const req = st.put(obj); req.onsuccess = ()=>res(req.result); req.onerror = ()=>rej(req.error); }); }
async function dbDel(id){ const db = await openDb(); return new Promise((res,rej)=>{ const tx = db.transaction(STORE,'readwrite'); const st = tx.objectStore(STORE); const req = st.delete(id); req.onsuccess = ()=>res(); req.onerror = ()=>rej(req.error); }); }

/* ============================
   Utilities
   ============================ */
function uid(prefix='id'){ return prefix+'-'+Math.random().toString(36).slice(2,10); }
function now(){ return Date.now(); }
function clampNumberString(s){
  if (s === '' || s === null || s === undefined) return null;
  s = String(s).trim();
  if (/^[-+]?\d*\.?\d+$/.test(s)) return Number(s);
  return null;
}
function escapeHTML(s){
  if (s === null || s === undefined) return '';
  return String(s).replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#039;"}[c]));
}

/* ============================
   App state & routing
   ============================ */
let STATE = { route: 'home', sheetId: null, sheets: [], archived: [] };
const main = document.getElementById('main');
const modalRoot = document.getElementById('modalRoot');

async function loadState(){
  const all = await dbGetAll();
  STATE.sheets = all.filter(s => !s.archived).sort((a,b)=>b.updatedAt - a.updatedAt);
  STATE.archived = all.filter(s => s.archived).sort((a,b)=>b.updatedAt - a.updatedAt);
}

function navigateTo(route){
  location.hash = '#'+route;
}

window.addEventListener('hashchange', renderRoute);

/* ============================
   Routing & render
   ============================ */
async function renderRoute(){
  await loadState();
  const hash = location.hash.replace('#','');
  if (!hash || hash === 'home'){ STATE.route = 'home'; STATE.sheetId = null; renderHome(); return; }
  if (hash.startsWith('new')) { STATE.route = 'new'; renderNew(); return; }
  if (hash.startsWith('sheet/')) {
    STATE.route = 'sheet';
    STATE.sheetId = hash.split('/')[1];
    await renderSheet(STATE.sheetId);
    return;
  }
  if (hash.startsWith('archive')) { STATE.route = 'archive'; renderArchive(); return; }
  if (hash.startsWith('leaderboard')) {
    STATE.route = 'leader';
    STATE.sheetId = hash.split('/')[1];
    await renderLeader();
    return;
  }
  // fallback
  STATE.route = 'home'; renderHome();
}

/* Update bottom-left navigation pill based on current route */
function updateBottomLeftPill(){
  const homeBtn2 = document.getElementById('homeBtn2');
  const secondBtn2 = document.getElementById('secondBtn2');
  // Home button ALWAYS shows
  homeBtn2.style.display = '';
  homeBtn2.onclick = ()=> navigateTo('home');
  
  if (STATE.route === 'home') {
    secondBtn2.style.display = ''; secondBtn2.title = 'Archived Sheets'; secondBtn2.innerText = 'üóÑÔ∏è';
    secondBtn2.onclick = ()=> navigateTo('archive');
  } else if (STATE.route === 'archive') {
    secondBtn2.style.display = 'none';
  } else if (STATE.route === 'sheet') {
    secondBtn2.style.display = ''; secondBtn2.title = 'Leaderboard'; secondBtn2.innerText = 'üìä';
    secondBtn2.onclick = ()=> navigateTo('leaderboard/' + STATE.sheetId);
  } else if (STATE.route === 'leader') {
    secondBtn2.style.display = ''; secondBtn2.title = 'Scoresheet'; secondBtn2.innerText = 'üìù';
    secondBtn2.onclick = ()=> { if (STATE.sheetId) navigateTo('sheet/' + STATE.sheetId); else navigateTo('home'); };
  } else if (STATE.route === 'new') {
    secondBtn2.style.display = 'none';
  } else {
    secondBtn2.style.display = 'none';
  }
}

/* ============================
   Home view
   ============================ */
function renderHome(){
  // Hide bottom-right pill on home
  const bottomRightPill = document.getElementById('bottomRightPill');
  bottomRightPill.style.display = 'none';
  updateBottomLeftPill();

  // Show the home-only plus pill and wire it to create a new scoresheet
  const homePlus = document.getElementById('homePlusPill');
  if (homePlus) {
    homePlus.style.display = '';
    const hpBtn = document.getElementById('homePlusBtn');
    if (hpBtn) hpBtn.onclick = () => navigateTo('new');
  }

  main.innerHTML = '';
    const el = elt('div',{class:'card'}, [
      elt('div',{}, [ elt('h1',{}, [ elt('em',{}, 'Score-It!'), ' by Bryce' ]), elt('div',{class:'muted'}, 'Keep score of anything! Click \'New Scoresheet\' to get started.') ]),
    elt('div',{class:'home-actions', style:'margin-top:12px'}, [
      elt('button',{class:'btn', onclick:()=> navigateTo('new')}, 'New Scoresheet')
    ])
  ]);
  main.appendChild(el);

  const activeCard = elt('div',{class:'card'}, [
    elt('div',{style:'display:flex;justify-content:space-between;align-items:center'}, [
      elt('div',{}, [ elt('div',{style:'font-weight:700'}, 'Active Scoresheets'), elt('div',{class:'muted'}, `${STATE.sheets.length} active`) ])
    ]),
    elt('div',{id:'activeList', style:'margin-top:10px'})
  ]);
  main.appendChild(activeCard);

  renderActiveList();

  // Add footer with "Made by Bryce" on home page only
  const footerDiv = elt('div',{style:'margin-top:20px;display:flex;justify-content:flex-end;padding:0 14px'}, []);
  const footerText = document.createElement('div');
  footerText.className = 'muted';
  footerText.style.fontSize = '13px';
  footerText.innerHTML = 'Made by <a href="https://instagram.com/bryceonboard" target="_blank" style="color:inherit;text-decoration:underline">Bryce</a> ‚ô°';
  footerDiv.appendChild(footerText);
  main.appendChild(footerDiv);
}

function renderActiveList(){
  const container = document.getElementById('activeList');
  container.innerHTML = '';
  if (!STATE.sheets.length) {
    container.appendChild(elt('div',{class:'muted'}, 'No active scoresheets yet.'));
    return;
  }
  STATE.sheets.forEach(s=>{
    const row = elt('div',{class:'card', style:'display:flex;justify-content:space-between;align-items:center'}, [
      elt('div',{}, [
        elt('div',{style:'font-weight:700'}, escapeHTML(s.title || 'Untitled')),
        elt('div',{class:'muted', style:'font-size:13px;'}, new Date(s.createdAt).toLocaleString())
      ]),
      elt('div',{}, [
      elt('button',{class:'btn ghost', style:'color: var(--accent-2)', onclick:()=> archiveSheet(s.id)}, 'Archive'),
      elt('button',{class:'btn', style:'margin-left:8px;', onclick:()=> navigateTo('sheet/'+s.id)}, 'Open')
      ])
    ]);
    container.appendChild(row);
  });
}

/* archive and restore */
async function archiveSheet(id){
  const s = await dbGet(id);
  if (!s) return alert('Not found');
  s.archived = true;
  s.updatedAt = now();
  await dbPut(s);
  await loadState();
  renderRoute();
}
async function restoreSheet(id){
  const s = await dbGet(id);
  if (!s) return alert('Not found');
  s.archived = false;
  s.updatedAt = now();
  await dbPut(s);
  await loadState();
  navigateTo('home');
}
async function deleteArchivedSheet(id){
  await dbDel(id);
  await loadState();
  renderRoute();
}

/* ============================
   Archive view
   ============================ */
function renderArchive(){
  // Hide bottom-right pill on archive
  const bottomRightPill = document.getElementById('bottomRightPill');
  bottomRightPill.style.display = 'none';
  updateBottomLeftPill();

  // Ensure the home-only plus pill is hidden on archive view
  const homePlusHide = document.getElementById('homePlusPill');
  if (homePlusHide) homePlusHide.style.display = 'none';

  main.innerHTML = '';
  main.appendChild(elt('div',{class:'card'}, [ elt('h1',{}, 'Archived Scoresheets'), elt('div',{class:'muted'}, 'Archived sheets are read-only. Restore to make edits.') ]));

  const list = elt('div',{class:'card'}, [ elt('div',{id:'archList'}) ]);
  main.appendChild(list);
  const container = document.getElementById('archList');
  container.innerHTML = '';
  if (!STATE.archived.length) container.appendChild(elt('div',{class:'muted'}, 'No archived sheets.'));
  STATE.archived.forEach(s=>{
    const row = elt('div',{class:'card', style:'display:flex;justify-content:space-between;align-items:center'}, [
      elt('div',{}, [
        elt('div',{style:'font-weight:700'}, escapeHTML(s.title || 'Untitled')),
        elt('div',{class:'muted', style:'font-size:13px;'}, new Date(s.updatedAt || s.createdAt).toLocaleString())
      ]),
      elt('div',{}, [
        elt('button',{class:'btn ghost', onclick:()=> restoreSheet(s.id)}, 'Restore'),
        // inline confirm delete: first click toggles text to 'Confirm?'
        elt('button',{class:'btn', style:'margin-left:8px', 'data-confirm':'no', onclick:(e)=> handleArchiveDeleteClick(e,s.id)}, 'Delete')
      ])
    ]);
    container.appendChild(row);
  });
  const DB_NAME = 'scorekeeper-db'; // Your existing constant

main.appendChild(elt('div', { class: 'card' }, [
  elt('div', { style: 'display: flex; justify-content: space-between; align-items: center;' }, [
    elt('h1', {}, 'Reset Memory & Cache'),
    elt('div', { style: 'display: flex; gap: 8px;' }, [
      elt('button', {
        class: 'btn ghost',
        style: 'color: var(--accent);',
        onclick: async () => {
          try {
            // Unregister all service workers
            const registrations = await navigator.serviceWorker.getRegistrations();
            for (let reg of registrations) {
              await reg.unregister();
            }
            console.log('Service workers unregistered. Reloading...');
            // Hard reload to bypass cache and fetch latest code
            window.location.reload(true);
          } catch (err) {
            console.error('Error updating:', err);
            alert('Update failed. Please try refreshing manually (Cmd+Shift+R on Mac).');
          }
        }
      }, 'Update'),
      elt('button', {
        class: 'btn ghost',
        style: 'color: var(--accent-2);',
        onclick: () => {
        if (confirm('‚ö†Ô∏è Are you sure you want to reset EVERYTHING? This will clear all scores, settings, local memory, and caches.')) {
          
          // --- 1. CLEAR BROWSER STORAGE (localStorage & sessionStorage) ---
          localStorage.clear();
          sessionStorage.clear();
          console.log('Local and session storage cleared.');

          // --- 2. CLEAR INDEXEDDB ---
          const dbDeleteRequest = indexedDB.deleteDatabase(DB_NAME);

          dbDeleteRequest.onsuccess = () => {
            console.log(`IndexedDB database '${DB_NAME}' cleared successfully.`);
            triggerServiceWorkerCacheClear();
          };

          dbDeleteRequest.onerror = (event) => {
            console.error('Error clearing IndexedDB:', event.target.error);
            // Continue to clear cache even if DB clear fails
            triggerServiceWorkerCacheClear();
          };

          // Handle the case where the database is open by another connection
          dbDeleteRequest.onblocked = () => {
             console.warn('IndexedDB deletion blocked. Close all open connections to the database and try again.');
             alert('Could not fully clear data. Please close any other tabs using this app and try again.');
          };
          
          function triggerServiceWorkerCacheClear() {
            // --- 3. CLEAR CACHE VIA SERVICE WORKER & RELOAD ---
            if (navigator.serviceWorker.controller) {
              navigator.serviceWorker.controller.postMessage({
                type: 'CLEAR_ALL_CACHES'
              });
              
              // Wait for the Service Worker to process the cache clear, then force a hard reload
              setTimeout(() => {
                console.log('Caches cleared via Service Worker. Reloading...');
                window.location.reload(true); 
              }, 500);
            } else {
              console.log('No active Service Worker. Reloading...');
              window.location.reload(true);
            }
          }
        } // end if(confirm)
        }
      }, 'Reset')
    ])
  ])
]));
}
function handleArchiveDeleteClick(e,id){
  const btn = e.currentTarget;
  if (btn.dataset.confirm === 'no'){
    btn.dataset.confirm = 'yes'; btn.innerText = 'Confirm?';
    setTimeout(()=>{ if (btn) { btn.dataset.confirm = 'no'; btn.innerText = 'Delete'; } }, 3000);
  } else {
    // confirmed
    deleteArchivedSheet(id);
  }
}

/* ============================
   New sheet view
   ============================ */
let draftSaveTimer = null;
function saveDraftDebounced(title, names){
  if (draftSaveTimer) clearTimeout(draftSaveTimer);
  draftSaveTimer = setTimeout(() => {
    saveDraft(title, names);
  }, 300);
}
function renderNew(){
  // Hide bottom-right pill on new
  const bottomRightPill = document.getElementById('bottomRightPill');
  bottomRightPill.style.display = 'none';
  updateBottomLeftPill();

  // Hide the home-only plus pill on the new sheet view
  const homePlusHide = document.getElementById('homePlusPill');
  if (homePlusHide) homePlusHide.style.display = 'none';

  main.innerHTML = '';
  // Load draft if it exists
  const draft = loadDraft();
  const el = elt('div',{class:'card'}, [
    elt('h1',{}, 'New Scoresheet'),
    elt('label',{}, 'Title'),
    elt('input',{type:'text', id:'sheetTitle', placeholder:'Title (optional)', value: draft?.title || ''}),
    elt('label',{}, 'Names (one per line)'),
    elt('textarea',{id:'namesInput', placeholder:'Bryce\nMatthew\nHollie'}, draft?.names || ''),
    elt('div',{style:'display:flex;gap:8px;margin-top:10px;align-items:center;justify-content:space-between'}, [
      elt('div',{style:'display: flex; gap: 8px;'}, [
        elt('button',{class:'btn', onclick:startNewSheet}, 'Start Scoring'),
        elt('button',{class:'btn ghost', onclick:()=> navigateTo('home')}, 'Cancel')
      ]),
      elt('button',{class:'btn ghost', style:'color:var(--accent-2)', 'data-confirm':'no', onclick:(e)=> handleClearDraft(e)}, 'Clear')
    ])
  ]);
  main.appendChild(el);
  // Attach auto-save listeners to both inputs
  const titleInput = document.getElementById('sheetTitle');
  const namesInput = document.getElementById('namesInput');
  titleInput.addEventListener('input', () => {
    saveDraftDebounced(titleInput.value, namesInput.value);
  });
  namesInput.addEventListener('input', () => {
    saveDraftDebounced(titleInput.value, namesInput.value);
  });
  titleInput.focus();
}
function handleClearDraft(e){
  const btn = e.currentTarget;
  if (btn.dataset.confirm === 'no'){
    btn.dataset.confirm = 'yes'; btn.innerText = 'Confirm Clear?';
    setTimeout(()=>{ if (btn) { btn.dataset.confirm = 'no'; btn.innerText = 'Clear'; } }, 3000);
  } else {
    // confirmed: clear the draft and the input fields
    clearDraft();
    document.getElementById('sheetTitle').value = '';
    document.getElementById('namesInput').value = '';
    document.getElementById('sheetTitle').focus();
  }
}
async function startNewSheet(){
  const t = document.getElementById('sheetTitle').value.trim() || 'Untitled';
  const namesRaw = document.getElementById('namesInput').value.split('\n').map(s=>s.trim()).filter(Boolean);
  if (!namesRaw.length) return alert('Add at least one name.');
  const initialRounds = 1;
  const sheet = {
    id: uid('sheet'),
    title: t,
    createdAt: now(),
    updatedAt: now(),
    archived: false,
    currentRoundIndex: 0, // 0-based
    contestants: namesRaw.map(n=>({ id: uid('c'), name: n, scores: Array(initialRounds).fill(null) }))
  };
  await dbPut(sheet);
  clearDraft();
  navigateTo('sheet/'+sheet.id);
  await loadState();
}

/* ============================
   Sheet (scoring) view
   ============================ */
let sheetCache = null;
let saveTimer = null;
let activeContestantIndex = 0;
let selectedRound = 0;

async function renderSheet(id){
  // Show bottom-right pill (jumpToLatest) only on sheet view
  const bottomRightPill = document.getElementById('bottomRightPill');
  bottomRightPill.style.display = '';
  const jumpBtn = document.getElementById('jumpBtn');
  jumpBtn.onclick = ()=> jumpToLatest();
  updateBottomLeftPill();

  // Ensure the home-only plus pill is hidden on sheet view
  const homePlusHide = document.getElementById('homePlusPill');
  if (homePlusHide) homePlusHide.style.display = 'none';

  // top pill second button -> leaderboard (show)
  const secondBtn = document.getElementById('secondBtn');
  secondBtn.style.display = ''; secondBtn.title = 'Leaderboard';
  secondBtn.innerText = 'üìä';
  secondBtn.onclick = ()=> navigateTo('leaderboard/' + id);

  sheetCache = await dbGet(id);
  if (!sheetCache) { alert('Sheet not found'); navigateTo('home'); return; }
  if (sheetCache.archived) { alert('This sheet is archived and read-only. Restore to edit.'); navigateTo('home'); return; }

  // ensure minimal structure
  sheetCache.contestants = sheetCache.contestants || [];
  if (sheetCache.contestants.length === 0) sheetCache.contestants.push({ id: uid('c'), name: 'Contestant', scores: [null] });
  // ensure all contestants have same scores length
  const roundsLen = sheetCache.contestants[0].scores.length || 1;
  sheetCache.contestants.forEach(c => { if (!c.scores) c.scores = Array(roundsLen).fill(null); while (c.scores.length < roundsLen) c.scores.push(null); });

  if (typeof sheetCache.currentRoundIndex !== 'number') sheetCache.currentRoundIndex = 0;
  selectedRound = sheetCache.currentRoundIndex;

  activeContestantIndex = 0;
  main.innerHTML = '';

  // header layout per spec:
  // Line 1: Name & rename pencil (left)  ----  Right: Round dropdown, Add Round
  // Line 2: Contestants: # (left)  ----  Right: Latest, Delete Round, Archive
  const line1 = elt('div',{class:'title-row'}, [
    elt('div',{class:'title-left'}, [
      elt('div',{}, elt('h1',{class:'rename-icon',onclick:renameSheet}, escapeHTML(sheetCache.title))),
    ]),
    elt('div',{style:'display:flex;align-items:center;gap:8px'}, [
      renderRoundDropdown(),
      elt('button',{class:'small', onclick:addRound}, 'New Round')
    ])
  ]);

  const line2 = elt('div',{style:'display:flex;justify-content:space-between;align-items:top;margin-top:8px'}, [
    elt('div',{style:'margin-left:5px'}, elt('div',{class:'muted'}, `Contestants: ${sheetCache.contestants.length}`)),
    elt('div',{}, [
      elt('button',{class:'btn ghost', style:'margin-left:6px;color: var(--accent)', onclick:deleteRound}, 'Delete Round'),
      elt('button',{class:'btn ghost', style:'margin-left:8px;color: var(--accent-2)', onclick:()=> archiveCurrentSheet(sheetCache.id)}, 'Archive Sheet')
    ])
  ]);

  main.appendChild(elt('div',{class:'card'}, [ line1, line2 ]));

  // list & controls
  const listCard = elt('div',{class:'card'}, [ elt('div',{id:'listContainer', class:'list'}) ]);
  main.appendChild(listCard);

  const bottomBar = elt('div',{style:'margin-top:10px;display:flex;justify-content:space-between;align-items:center;gap:8px'}, [
    elt('div',{}, [
      elt('button',{class:'small', onclick:()=> showAddContestantInline()}, '+ Add Contestant')
    ]),
    elt('div',{}, [
      elt('button',{class:'btn ghost', onclick:()=> navigateTo('home')}, 'Back to Home')
    ])
  ]);
  main.appendChild(bottomBar);

  renderContestantList();
  document.getElementById('homeBtn').onclick = ()=> navigateTo('home');
  document.getElementById('secondBtn').onclick = ()=> navigateTo('leaderboard/' + sheetCache.id);
}

/* round dropdown renderer */
function renderRoundDropdown(){
  // 1. Create the <select> element (your existing code)
  const sel = document.createElement('select');
  sel.id = 'roundSelect';
  const rounds = sheetCache.contestants[0]?.scores?.length || 1;
  for (let i=0;i<rounds;i++){
    const opt = document.createElement('option');
    opt.value = i;
    opt.textContent = `Round ${i+1}`;
    if (i === selectedRound) opt.selected = true;
    sel.appendChild(opt);
  }
  sel.addEventListener('change', (e)=>{
    selectedRound = Number(e.target.value);
    renderContestantList();
  });
  
  // 2. Create and append to the wrapper
  const wrapper = document.createElement('div');
  wrapper.className = 'dropdown-wrapper';
  wrapper.appendChild(sel);
  
  // Return the wrapper, which includes the dropdown and the icon from CSS
  return wrapper;
}

/* helper to update dropdown options and selection after rounds change */
function updateRoundDropdown(){
  const sel = document.getElementById('roundSelect');
  if (!sel) return;
  sel.innerHTML = '';
  const rounds = sheetCache.contestants[0]?.scores?.length || 1;
  for (let i=0;i<rounds;i++){
    const opt = document.createElement('option');
    opt.value = i;
    opt.textContent = `Round ${i+1}`;
    if (i === selectedRound) opt.selected = true;
    sel.appendChild(opt);
  }
}

/* archive sheet */
async function archiveCurrentSheet(id){
  if (!confirm('Archive this sheet? You can restore it later.')) return;
  const s = await dbGet(id);
  s.archived = true; s.updatedAt = now();
  await dbPut(s);
  await loadState();
  navigateTo('home');
}

/* rename sheet */
function renameSheet(){
  const newName = prompt('Rename sheet', sheetCache.title);
  if (newName === null) return;
  sheetCache.title = newName.trim() || sheetCache.title;
  sheetCache.updatedAt = now();
  dbPut(sheetCache);
  renderSheet(sheetCache.id);
}

/* render contestants */
function renderContestantList(){
  const container = document.getElementById('listContainer');
  container.innerHTML = '';
  sheetCache.contestants.forEach((c, idx) => {
    const subtitleHtml = buildSubtitleSafe(c.scores, selectedRound);
    const rowWrap = document.createElement('div');
    rowWrap.className = 'swipe-wrap';
    const row = document.createElement('div');
    row.className = 'row' + (idx === activeContestantIndex ? ' active' : '');
    // left
    const left = document.createElement('div'); left.className = 'left';
    const nameEl = document.createElement('div'); nameEl.className = 'name'; nameEl.textContent = c.name;
    const subEl = document.createElement('div'); subEl.className = 'subtitle'; subEl.style.marginTop = '6px';
    // subtitle contains HTML (strong tags)
    subEl.innerHTML = subtitleHtml;
    left.appendChild(nameEl); left.appendChild(subEl);
    left.addEventListener('click', ()=> openContestantModal(idx));
    // right
    const right = document.createElement('div'); right.className = 'right';
    const input = document.createElement('input');
    input.className = 'score-input';
    input.value = valueOrEmpty(c.scores[selectedRound]);
    input.setAttribute('data-idx', String(idx));
    input.setAttribute('data-round', String(selectedRound));
    input.setAttribute('inputmode', 'decimal');
    input.placeholder = '‚Äî';
    input.addEventListener('keydown', onScoreKeyDown);
    input.addEventListener('input', onScoreInput);
    // Track which contestant input was last focused so the tab-sentinel knows
    // which contestant to advance from when it receives focus (useful on iOS numeric keyboards).
    // Also update row styling when focused or blurred
    input.addEventListener('focus', () => {
      activeContestantIndex = idx;
      updateActiveRowStyling();
    });
    input.addEventListener('blur', () => {
      updateActiveRowStyling();
    });
    right.appendChild(input);
    // assemble
    row.appendChild(left); row.appendChild(right);
    rowWrap.appendChild(row);
    container.appendChild(rowWrap);
  });

  // Add a hidden "tab sentinel" input at the end of the list. On devices
  // (notably iOS numeric keyboard) where the numeric keyboard doesn't provide
  // a visible Enter/Return, tabbing to this sentinel should emulate pressing
  // Enter: move focus to the next contestant and trigger auto-advance when
  // on the latest round.
  (function ensureTabSentinel(){
    let sentinel = document.getElementById('tabSentinel');
    if (!sentinel){
      sentinel = document.createElement('input');
      sentinel.type = 'text';
      sentinel.id = 'tabSentinel';
      // Keep it visually minimal but focusable.
      sentinel.style.opacity = '0';
      sentinel.style.height = '1px';
      sentinel.style.width = '1px';
      sentinel.style.border = '0';
      sentinel.style.padding = '0';
      sentinel.style.margin = '0';
      sentinel.style.background = 'transparent';
      sentinel.style.position = 'relative';
      // When focused, behave like Enter on the currently active contestant.
      sentinel.addEventListener('focus', () => {
        // Fallback if no active index known
        const idx = (typeof activeContestantIndex === 'number' && activeContestantIndex >= 0) ? activeContestantIndex : 0;
        const next = (idx + 1) % sheetCache.contestants.length;
        focusContestant(next, true);
        const latestIndex = (sheetCache.contestants[0] && sheetCache.contestants[0].scores) ? sheetCache.contestants[0].scores.length - 1 : 0;
        if (selectedRound === latestIndex) maybeAutoAdvanceRound();
      });
    }
    // Ensure sentinel is last in the container so Tab order reaches it after score inputs.
    container.appendChild(sentinel);
  })();
}

/* subtitle builder that returns HTML string (escape contents, wrap active with <strong>) */
function buildSubtitleSafe(scores, activeIdx){
  const parts = scores.map((s,i)=> {
    const display = (s === null || s === undefined) ? '‚Äî' : String(s);
    if (i === activeIdx) return `<strong>${escapeHTML(display)}</strong>`;
    return escapeHTML(display);
  });
  const total = scores.reduce((sum, x) => sum + (typeof x === 'number' ? x : 0), 0);
  return `${parts.join(', ')}  |  <strong>${escapeHTML(String(total))}</strong>`;
}

function valueOrEmpty(v){ return (v === null || v === undefined) ? '' : String(v); }

/* Update active row styling based on which input has focus */
function updateActiveRowStyling(){
  const listContainer = document.getElementById('listContainer');
  if (!listContainer) return;
  const rows = Array.from(listContainer.querySelectorAll('.row'));
  rows.forEach((row, rIdx) => {
    if (rIdx === activeContestantIndex) {
      row.classList.add('active');
    } else {
      row.classList.remove('active');
    }
  });
}

/* score input handlers */
function onScoreInput(e){
  const input = e.target;
  const idx = Number(input.dataset.idx);
  const round = Number(input.dataset.round);
  const parsed = clampNumberString(input.value);
  sheetCache.contestants[idx].scores[round] = parsed;
  scheduleSave();
  updateSubtitleForRow(idx);
}
function updateSubtitleForRow(idx){
  const container = document.getElementById('listContainer');
  if (!container) return;
  const subtitleNodes = container.querySelectorAll('.subtitle');
  if (subtitleNodes[idx]) subtitleNodes[idx].innerHTML = buildSubtitleSafe(sheetCache.contestants[idx].scores, selectedRound);
}

/* Enter key: move to next within selectedRound, wrap to first; if on latest round, check auto-advance */
function onScoreKeyDown(e){
  if (e.key === 'Enter') {
    e.preventDefault();
    const input = e.target;
    const idx = Number(input.dataset.idx);
    let next = (idx + 1) % sheetCache.contestants.length;
    focusContestant(next, true);
    const latestIndex = sheetCache.contestants[0].scores.length - 1;
    if (selectedRound === latestIndex) maybeAutoAdvanceRound();
  }
}

/* focus */
function focusContestant(idx, forceFocus=false){
  activeContestantIndex = idx;
  const listContainer = document.getElementById('listContainer');
  if (!listContainer) return;
  Array.from(listContainer.querySelectorAll('.row')).forEach((row, rIdx)=>{
    if (rIdx === idx) row.classList.add('active'); else row.classList.remove('active');
  });
  const input = listContainer.querySelector(`input[data-idx="${idx}"]`);
  if (input && (forceFocus || document.activeElement !== input)) {
    input.focus();
    setTimeout(()=> input.setSelectionRange(input.value.length, input.value.length), 50);
  }
}

/* auto-advance only when on latest round and all contestants have numeric value for that round */
function maybeAutoAdvanceRound(){
  const latest = sheetCache.contestants[0].scores.length - 1;
  const allHave = sheetCache.contestants.every(c => typeof c.scores[latest] === 'number');
  if (allHave) {
    sheetCache.contestants.forEach(c => c.scores.push(null));
    sheetCache.currentRoundIndex = sheetCache.contestants[0].scores.length - 1;
    selectedRound = sheetCache.currentRoundIndex;
    scheduleSave();
    updateRoundDropdown();
    renderContestantList();
    focusContestant(0, true);
  }
}

/* add round manually */
function addRound(){
  sheetCache.contestants.forEach(c => c.scores.push(null));
  sheetCache.currentRoundIndex = sheetCache.contestants[0].scores.length - 1;
  selectedRound = sheetCache.currentRoundIndex;
  scheduleSave();
  updateRoundDropdown();
  renderContestantList();
}

/* delete round: remove selectedRound across all contestants; handle edge cases */
function deleteRound(){
  const rounds = sheetCache.contestants[0].scores.length;
  if (rounds <= 1){
    // reset to single round with nulls
    sheetCache.contestants.forEach(c => c.scores = [null]);
    selectedRound = 0;
    sheetCache.currentRoundIndex = 0;
    scheduleSave();
    updateRoundDropdown();
    renderContestantList();
    return;
  }
  if (!confirm(`Delete Round ${selectedRound+1}? This will remove that round for everyone.`)) return;
  sheetCache.contestants.forEach(c => {
    c.scores.splice(selectedRound, 1);
    // ensure at least one element
    if (c.scores.length === 0) c.scores.push(null);
  });
  // shift selectedRound to previous if possible
  selectedRound = Math.max(0, selectedRound - 1);
  // also update currentRoundIndex to last index
  sheetCache.currentRoundIndex = sheetCache.contestants[0].scores.length - 1;
  scheduleSave();
  updateRoundDropdown();
  renderContestantList();
}

/* jump to latest round and focus first contestant without a score at that round */
/* also auto-advance the round if all contestants have filled the current round */
function jumpToLatest(){
  const latestIndex = sheetCache.contestants[0].scores.length - 1;
  const allFilled = sheetCache.contestants.every(c => typeof c.scores[latestIndex] === 'number');
  
  // If current latest round is complete, auto-advance to next round
  if (allFilled) {
    sheetCache.contestants.forEach(c => c.scores.push(null));
    sheetCache.currentRoundIndex = sheetCache.contestants[0].scores.length - 1;
    selectedRound = sheetCache.currentRoundIndex;
    scheduleSave();
    updateRoundDropdown();
  }
  
  // Now jump to latest and find first empty
  const currentLatest = sheetCache.contestants[0].scores.length - 1;
  selectedRound = currentLatest;
  updateRoundDropdown();
  let idx = sheetCache.contestants.findIndex(c => c.scores[currentLatest] === null || c.scores[currentLatest] === undefined);
  if (idx === -1) idx = 0;
  renderContestantList();
  focusContestant(idx, true);
}

/* Add contestant inline (enter to confirm) */
function showAddContestantInline(){
  const container = document.getElementById('listContainer');
  const addRow = elt('div',{class:'card', style:'margin-top:8px;display:flex;gap:8px;align-items:center'}, [
    elt('input',{type:'text', id:'newContestantName', placeholder:'New contestant name'}),
    elt('button',{class:'btn', onclick:addContestantFromInline}, 'Add')
  ]);
  container.appendChild(addRow);
  const input = document.getElementById('newContestantName');
  input.focus();
  input.addEventListener('keydown', (e)=> { if (e.key === 'Enter') { addContestantFromInline(); } });
}
function addContestantFromInline(){
  const nameEl = document.getElementById('newContestantName');
  if (!nameEl) return;
  const name = nameEl.value.trim();
  if (!name) return alert('Enter a name');
  // set scores: pad zeros for previous rounds (all existing rounds)
  const roundsCount = sheetCache.contestants[0]?.scores?.length || 1;
  const scores = Array(roundsCount).fill(null);
  const c = { id: uid('c'), name, scores };
  sheetCache.contestants.push(c);
  sheetCache.updatedAt = now();
  scheduleSave();
  renderContestantList();
  focusContestant(sheetCache.contestants.length - 1, true);
}

/* schedule save (debounced) */
function scheduleSave(){
  if (saveTimer) clearTimeout(saveTimer);
  saveTimer = setTimeout(()=> {
    sheetCache.updatedAt = now();
    dbPut(sheetCache);
    loadState(); // refresh global lists
  }, 300);
}

/* ============================
   Contestant modal (edit name, edit all scores, delete)
   ============================ */
function openContestantModal(idx){
  const c = sheetCache.contestants[idx];
  showModal(renderContestantModal(c, idx));
}
function renderContestantModal(contestant, idx){
  const modal = elt('div',{class:'modal'}, [
    elt('h2',{}, 'Edit contestant'),
    elt('label',{}, 'Name'),
    elt('input',{type:'text', id:'modalName', value:contestant.name}),
    elt('label',{}, 'Scores (edit values for each round)'),
    elt('div',{style:'max-height:240px;overflow:auto;padding-right:8px'}, contestant.scores.map((s, i) => {
      return elt('div',{style:'display:flex;gap:8px;align-items:center;margin-bottom:8px'}, [
        elt('div',{}, `Round ${i+1}`),
        elt('input',{type:'text', id:`modal-score-${i}`, value: (s === null || s === undefined) ? '' : String(s), placeholder:'‚Äî', style:'flex:1;padding:8px;border-radius:8px;border:1px solid rgba(0,0,0,0.06)'})
      ]);
    })),
    elt('div',{style:'display:flex;justify-content:space-between;align-items:center;margin-top:12px'}, [
      elt('div',{}, [
        elt('button',{class:'delete-confirm', onclick:()=> handleDeleteContestant(idx)}, 'Delete')
      ]),
      elt('div',{}, [
        elt('button',{class:'btn ghost', onclick:closeModal}, 'Cancel'),
        elt('button',{class:'btn', style:'margin-left:8px', onclick:()=> saveContestantModal(idx)}, 'Save')
      ])
    ])
  ]);
  return modal;
}

function showModal(node){
  modalRoot.innerHTML = '';
  modalRoot.style.display = 'block';
  const backdrop = elt('div',{class:'modal-backdrop'}, node);
  modalRoot.appendChild(backdrop);
}
function closeModal(){ modalRoot.innerHTML = ''; modalRoot.style.display = 'none'; }

function saveContestantModal(idx){
  const name = document.getElementById('modalName').value.trim();
  if (!name) return alert('Name cannot be empty');
  const rounds = sheetCache.contestants[0].scores.length;
  const newScores = [];
  for (let i=0;i<rounds;i++){
    const el = document.getElementById(`modal-score-${i}`);
    const val = el ? clampNumberString(el.value) : null;
    newScores.push(val);
  }
  sheetCache.contestants[idx].name = name;
  sheetCache.contestants[idx].scores = newScores;
  sheetCache.updatedAt = now();
  scheduleSave();
  closeModal();
  renderContestantList();
}

function handleDeleteContestant(idx){
  if (!confirm('Delete contestant? This cannot be undone.')) return;
  sheetCache.contestants.splice(idx,1);
  if (activeContestantIndex >= sheetCache.contestants.length) activeContestantIndex = 0;
  scheduleSave();
  closeModal();
  renderContestantList();
}

/* ============================
   Leaderboard
   ============================ */


async function renderLeader(){
  // Hide bottom-right pill on leaderboard
  const bottomRightPill = document.getElementById('bottomRightPill');
  bottomRightPill.style.display = 'none';
  updateBottomLeftPill();

  // Ensure the home-only plus pill is hidden on leaderboard view
  const homePlusHide = document.getElementById('homePlusPill');
  if (homePlusHide) homePlusHide.style.display = 'none';

  document.getElementById('homeBtn').onclick = ()=> navigateTo('home');

  main.innerHTML = ''; // clear to avoid duplicate render
  const id = STATE.sheetId || sheetCache?.id;
  if (!id) { main.appendChild(elt('div',{class:'card'}, [ elt('h1',{}, 'Leaderboards'), elt('div',{class:'muted'}, 'No sheet selected') ])); return; }
  const sheet = await dbGet(id);
  if (!sheet) { navigateTo('home'); return; }

  main.appendChild(elt('div',{class:'card'}, [ elt('h1',{}, sheet.title + ' ‚Äî Leaderboard'), elt('div',{class:'muted'}, `Rounds: ${sheet.contestants[0]?.scores?.length || 1}`) ]));

  const t = document.createElement('table');
  t.className = 'leaderboard';
  const thead = t.createTHead();
  const hrow = thead.insertRow();
  hrow.appendChild(th('Name'));
  const rounds = sheet.contestants[0]?.scores?.length || 1;
  for (let r=0;r<rounds;r++) hrow.appendChild(th(`R${r+1}`));
  hrow.appendChild(th('Total'));
  const tbody = t.createTBody();
  const rows = sheet.contestants.map(c=>{
    const total = c.scores.reduce((s,x)=>s + (typeof x === 'number' ? x : 0), 0);
    return { id:c.id, name:c.name, scores:c.scores.slice(), total };
  });
  rows.sort((a,b)=>b.total - a.total);
  rows.forEach(rw=>{
    const tr = tbody.insertRow();
    tr.appendChild(td(rw.name));
    for (let i=0;i<rounds;i++) tr.appendChild(tdNum(rw.scores[i]));
    tr.appendChild(tdNum(rw.total));
  });
  // Card with leaderboard table
  main.appendChild(elt('div',{class:'card', style:'overflow:auto'}, [ t ]));

  // Place the "Back to Scoresheet" button below the card, matching the
  // placement used by the scoresheet view (+ Add Contestant). Left aligned.
  main.appendChild(elt('div',{style:'margin-top:8px;display:flex;justify-content:space-between;align-items:center;gap:8px'}, [
    elt('div',{}, [ elt('button',{class:'btn ghost', onclick:()=> navigateTo('sheet/'+sheet.id)}, 'Back to Scoresheet') ]),
    elt('div',{}, [])
  ]));

  function th(txt){ const el = document.createElement('th'); el.textContent = txt; return el; }
  function td(txt){ const el = document.createElement('td'); el.textContent = (txt===null || txt===undefined) ? '‚Äî' : String(txt); return el; }
  function tdNum(v){ const el = document.createElement('td'); el.className='numeric'; el.textContent = (v===null||v===undefined)?'‚Äî':String(v); return el; }
}

/* ============================
   Misc helpers & init
   ============================ */
function elt(tag, attrs={}, children=null){
  const el = document.createElement(tag);
  for (let k in attrs){
    if (k === 'onclick') el.addEventListener('click', attrs[k]);
    else if (k === 'oninput') el.addEventListener('input', attrs[k]);
    else if (k === 'onkeydown') el.addEventListener('keydown', attrs[k]);
    else el.setAttribute(k, attrs[k]);
  }
  if (children === null) return el;
  if (Array.isArray(children)){
    children.forEach(c => {
      if (typeof c === 'string') el.appendChild(document.createTextNode(c));
      else el.appendChild(c);
    });
  } else {
    if (typeof children === 'string') el.appendChild(document.createTextNode(children));
    else el.appendChild(children);
  }
  return el;
}

(async function init(){
  await loadState();
  if (!location.hash) location.hash = '#home';
  renderRoute();
  // register service worker
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js').catch(()=>{/* ignore */});
  }
  // wire Home button globally
  document.getElementById('homeBtn').onclick = ()=> navigateTo('home');
})();
</script>
</body>
</html>
